## Late Submission Disclosure
I acknowladge I have created the last commit after due date.
In short:
- I have not pushed the latest changes with the README and video on friday afternoon.
- My computer is failing to boot since Friday evening
- I have realized I have not pushed the commit on Sunday

## AI Usage Disclosure
I have used AI LLM (Claude 3.7) to discuss ideas, help with test development and writing code based on high level instructions. The submission contains code generated by AI; however, I did not inputted any part of the raw assignment and asked Claude to generate the code. Additionally, I used Claude to help me identify design rationales in the code and for improving the final documentation wording.

The conversations can be reviewed at:
https://claude.ai/chat/31cd74c3-eb59-430a-ad9c-8fc2fe2f5968
https://claude.ai/chat/85a90770-3d93-4bb1-8cc1-2b1940059a29
https://claude.ai/chat/7921bf95-0a9b-4d99-9b6d-046a020d89be
https://claude.ai/chat/f945baab-6e1d-44d2-9833-1d74dc8a63d0
https://claude.ai/chat/db1c8547-27a5-45d9-8a8b-9ba993055aa4 


## Video
https://drive.google.com/file/d/1H1ryqIxLjx8-ON30s5F7BxJxgM0lXiiu/view?usp=drive_link

The video contains changes to ID generation, which are not included in this version of the code.

## Setup and Usage

### Prerequisites
- Python 3.10 or higher
- Poetry (optional, for dependency management)

### Installation

1. Clone this repository
2. Install dependencies using one of the following methods:
   
   **Using Poetry (recommended):**
   ```bash
   poetry install
   ```
   
   **Using pip:**
   ```bash
   pip install -r requirements.txt
   ```

### Running the Application

Start the calculator application:
```bash
# Using Poetry
poetry run calculator

# Using Python directly
python -m src.app
```

### Available Commands

- Basic calculations: `add`, `subtract`, `multiply`, `divide`
- History management: `history`, `clear_history`, `delete_history`
- Other commands: `exit`, `greet`

### Example Usage

```
Enter a command: greet
Hello, world!

Enter a command: add 5 3
The result of 5 + 3 = 8

Enter a command: history
Calculation History:
ID: 1 | Operation: add | Operands: [5, 3] | Result: 8 | Timestamp: 2025-03-16 10:15:30

Enter a command: exit
Exiting the application...
```


## Design Rationale

### Design patterns

Here's the formatted description with class and function names in monospace font using markdown:

1. **Command Pattern**  
   - Implemented in `command.py` and `command_handler.py` for dynamic command loading and execution.  
   - Commands inherit from the abstract `Command` class and implement the `execute` method.  
   - The `CommandHandler` class manages command registration and execution.

2. **Facade Pattern | Calculator**  
   - Offers a simplified interface to the UI layer of the application that executes given operations.
   - `Calculator` serves as the facade for the application.
   - It clearly specifies an interface where you provide it with an operation reference, and it handles execution, history management, and all necessary steps for the application logic.

3. **Facade Pattern | CalculationHistory**  
   - `CalculationHistory` provides a clear interface for storing calculation records.
   - It abstracts the serialization and deserialization processes and handles potential exceptions that can arise from them.

4. **Repository Pattern**   
   - Used in the persistence layer with the `RepositoryInterface` abstraction.  
   - Enables the rest of the application to remain unaware of the storage logic. If we wanted to swap out CSV storage for a SQL database, we would only need to write a new `RepositoryInterface` implementation.

5. **Singleton Pattern**
   - Prevents bugs that could arise if multiple repositories or calculation histories existed in the application.
   - Ensures that only a single instance of the `Calculator`, `CalculationHistory`, and Repositories exists in the application.
   - Implemented using a decorator that intercepts object creation, tracks class instances, and returns existing instances instead of creating new ones.

6. **Dependency Injection**
   - Decouples the `Calculator`, `CalculationHistory`, and Repository classes to allow swapping different implementations and injecting mock classes for testing.
   - Achieved by passing dependencies as constructor parameters.
   - Combined with the Singleton pattern, initialization occurs in `application_context.py`, localizing the coupling of classes to one place.
   - The coupling can also be determined by environment variables, as demonstrated in the selection of repository type.

7. **Strategy Pattern**
   - Implemented in the `BinaryOperationExecutor` class, which accepts different operation callables as strategies that can be swapped at runtime.
   - The executor acts as the context, while operation functions serve as interchangeable strategies.
   - Provides a consistent framework for executing different binary operations while encapsulating the varying calculation logic.
   - Allows new operations to be added without modifying the execution logic, promoting open-closed principle.

   
### LBYL vs EAFTP

#### EAFP Approach (Easier to Ask for Forgiveness than Permission)

I generally prefer EAFP as it assumes the correct flow of the application and is the more "Pythonic" way. I've implemented it in:

- Getting inputs in `operation_executor`
- Executing a command: I do not check whether a command is registered or not. I simply try to execute it and if the execution fails then I handle it
- Command suggestion: I try to find matches similar to the command. If none are returned, I expect an index error when accessing them and it is later caught and resolved
- Handling of serialization and deserialization: If an invalid record is read from the database, error is thrown, caught and the particular record is skipped
- Serialization and deserialization: If invalid operation is present and cannot be parsed, again exception is thrown
- Performing operations and expecting the division by zero exception
- Singleton handling: Retrieval and deletion of singletons in `@singleton` decorated classes
- History commands and checking whether item exists / can be deleted in `HistoryCommand` and `DeleteHistoryCommand`
- In `CSVRepository` and `MemoryRepository` to handle the errors in data access

#### LBYL Approach (Look Before You Leap)

I use LBYL in specific cases:

- Checking arguments at the beginning of the application, mainly to prevent large try-catch blocks. Also this check is established approach
- Configuration loading: Not performance critical part of the application and if statement is easier to understand, the non-existence of logging conf. is expected situation
- Repositories (`CSVRepository` and `MemoryRepository`): Empty checks allow raising domain-specific exceptions, checking emptiness is faster than handling exceptions, empty pandas operations return empty results rather than exceptions, pre-checks make expected conditions explicit, and checking avoids unnecessary file operations


### Logging

The application implements a robust logging system that allows for flexible configuration and detailed monitoring:

- **Dual Configuration Options**: Logging can be configured either through a dedicated `logging.conf` file or via environment variables
- **Environment Variable Control**: Set `USE_ENV_LOGGING=true` to use environment variables instead of the config file
- **Customizable Log Levels**: Configure separate log levels for console (`LOG_LEVEL_CONSOLE`) and file (`LOG_LEVEL_FILE`) outputs
- **Log File Management**: Supports log file rotation and custom log directory location via `LOG_DIR` environment variable
- **Decorator-based Instrumentation**: The `@log_method` decorator simplifies adding consistent logging across the application

### Environment Variables

The application uses environment variables for flexible configuration without code changes:

- **REPOSITORY_TYPE**: Controls the storage mechanism (`csv` or `memory`) for calculation history
- **REPOSITORY_DATA_PATH**: Specifies the location of the CSV file when using the CSV repository (default: `data/calculations.csv`)
- **USE_ENV_LOGGING**: Set to `true` to configure logging via environment variables instead of `logging.conf`
- **LOG_LEVEL_CONSOLE**: Sets console output verbosity (WARNING, INFO, DEBUG, etc.)
- **LOG_LEVEL_FILE**: Sets log file verbosity level, which can differ from console level
- **LOG_DIR**: Directory where log files are stored (default: `logs`)
- **LOG_FILENAME**: Name of the log file (default: `app.log`)

This approach allows for easy deployment in different environments and simplifies testing by making dependencies configurable at runtime.


